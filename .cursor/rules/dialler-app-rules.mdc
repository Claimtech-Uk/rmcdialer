---
alwaysApply: true
---

## üíæ Database Configuration
### Environment URLs
- **PRODUCTION**: `postgres://neondb_owner:npg_G5Nva0ZuOWeR@ep-shy-silence-abdb9eor-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require`
- **DEV**: `postgres://neondb_owner:npg_mN8i5yfsCHlc@ep-spring-bar-ab16367j-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require`

**Note**: These are separate database instances for different environments.

### Schema Changes Guidelines
- Use `npx prisma db push` to apply schema changes (project avoids migrations to preserve data)
- Always backup schema before major changes: `cp prisma/schema.prisma prisma/schema.prisma.backup.$(date +%Y%m%d_%H%M%S)`
- **Test on DEV first**, then apply to PRODUCTION:
  ```bash
  # DEV
  DATABASE_URL="postgres://neondb_owner:npg_mN8i5yfsCHlc@ep-spring-bar-ab16367j-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require" npx prisma db push
  
  # PRODUCTION (after testing)
  DATABASE_URL="postgres://neondb_owner:npg_G5Nva0ZuOWeR@ep-shy-silence-abdb9eor-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require" npx prisma db push
  ```

### Agent Management Philosophy
- **Keep it simple**: Focus on essential fields only (role, team, allowedQueues, isActive, isAiAgent)
- **Avoid overengineering**: No departments, locations, complex hierarchies, or audit systems
- **Production-ready basics**: Roles (agent/supervisor/admin), Teams (unsigned/requirements/general), Queue access control


# Dialler System Development Rules

## üéØ Project Overview

### What We're Building
A production-ready standalone dialler system (dialler.resolvemyclaim.co.uk) built as a unified Next.js 14 application with tRPC. Enables agents to efficiently contact users about financial claims with 100% call accuracy.

**Status**: ‚úÖ **PRODUCTION READY** - All phases completed successfully!

### Core Business Goals
- **Increase claim completion rates** by proactively contacting users with pending requirements
- **Reduce friction** in the claims process by sending magic links for passwordless authentication
- **Prioritize high-value claims** through intelligent scoring and queue management
- **Track all interactions** for compliance and quality improvement
- **Scale operations** with both human and AI agents

### Key User Journeys
1. **Agent Login** ‚Üí View Queue ‚Üí Call User ‚Üí Disposition Call ‚Üí Next Call
2. **User Receives Call** ‚Üí Agent Explains Requirements ‚Üí Receives Magic Link ‚Üí Completes Claim
3. **Supervisor Views Dashboard** ‚Üí Monitors Performance ‚Üí Adjusts Strategies

## üèóÔ∏è Current Architecture

### Enhanced Pre-call Validation + Auto-Regeneration
- **Direct MySQL Replica**: Real-time validation before every call (zero wrong calls)
- **Auto-Regenerating Queues**: Maintains 20+ users automatically via separated queue tables
- **Enhanced Ordering**: Newest prospects prioritized, 2-hour cooling period
- **AI Voice Integration**: Hume EVI for conversational intelligence
- **Comprehensive Automation**: 7 background cron jobs for maintenance

### Production Capabilities
- **9,800+ users** actively managed with **28,943+ claims**
- **Zero wrong calls** through real-time validation
- **Auto-healing queues** with 5-minute monitoring
- **Sub-second response** times with optimized queries

## üìÅ Modulithic Architecture

### Core Principle
**Single Next.js application organized as domain modules** - NOT microservices.

```
üì¶ RMC Dialler (Single App)
‚îú‚îÄ‚îÄ üè† app/ (Next.js App Router - Presentation)
‚îú‚îÄ‚îÄ üîó server/ (tRPC Routers - API Layer)  
‚îú‚îÄ‚îÄ üè¢ modules/ (Business Domains - Modulithic)
‚îÇ   ‚îú‚îÄ‚îÄ auth/ (Authentication)
‚îÇ   ‚îú‚îÄ‚îÄ queue/ (Queue Management + Auto-regeneration)
‚îÇ   ‚îú‚îÄ‚îÄ calls/ (Call Sessions)
‚îÇ   ‚îú‚îÄ‚îÄ communications/ (SMS + Magic Links)
‚îÇ   ‚îú‚îÄ‚îÄ users/ (User Context)
‚îÇ   ‚îú‚îÄ‚îÄ scoring/ (Priority Algorithms)
‚îÇ   ‚îú‚îÄ‚îÄ analytics/ (Reporting)
‚îÇ   ‚îú‚îÄ‚îÄ ai-voice-agent/ (Hume Integration)
‚îÇ   ‚îî‚îÄ‚îÄ core/ (Shared Infrastructure)
‚îú‚îÄ‚îÄ üóÑÔ∏è lib/ (Infrastructure)
‚îî‚îÄ‚îÄ üóÑÔ∏è prisma/ (Database)
```

### Module Boundaries & Dependencies
```typescript
// ‚úÖ Allowed dependencies (top can depend on bottom):
app/ ‚Üí server/ ‚Üí modules/ ‚Üí core/ ‚Üí lib/

// ‚úÖ Module dependency hierarchy:
analytics ‚Üí all other modules
calls ‚Üí core + auth + queue + users
queue ‚Üí core + auth + users + scoring
communications ‚Üí core + auth + users
scoring ‚Üí core + users
auth ‚Üí core
users ‚Üí core
ai-voice-agent ‚Üí core + calls

// ‚ùå Forbidden: core cannot depend on business modules
// ‚ùå Forbidden: Cross-module internal imports
```

### Module Interface Pattern
```typescript
// Every module exports clean interface via index.ts
// modules/queue/index.ts
export { QueueService } from './services/queue.service'
export { useQueue } from './hooks/useQueue'
export type { Queue, QueueEntry } from './types/queue.types'

// Usage: import { QueueService } from '@/modules/queue'
// ‚ùå Never: import from '@/modules/queue/services/queue.service'
```

## üîß Technology Stack

### Current Production Stack
- **Framework**: Next.js 14 (App Router) + TypeScript
- **API**: tRPC + TanStack Query for type-safe client/server
- **Database**: PostgreSQL (separated queues) + MySQL Replica (user data)
- **AI**: Hume EVI + OpenAI + TTS pipeline
- **Communication**: Twilio Voice + SMS
- **Deployment**: Vercel with automated cron jobs
- **Monitoring**: Winston logging + health checks

## üìù Development Standards

### tRPC Procedure Pattern
```typescript
export const exampleRouter = createTRPCRouter({
  getItems: protectedProcedure
    .input(z.object({
      page: z.number().default(1),
      filters: z.object({
        status: z.string().optional()
      }).optional()
    }))
    .query(async ({ input, ctx }) => {
      // Delegate to module service
      return await moduleService.getItems(input, ctx.agent)
    }),

  createItem: protectedProcedure
    .input(CreateItemSchema)
    .mutation(async ({ input, ctx }) => {
      return await moduleService.createItem(input, ctx.agent.id)
    })
});
```

### Error Handling
```typescript
import { TRPCError } from '@trpc/server';

// Always use TRPCError with appropriate codes
throw new TRPCError({
  code: 'UNAUTHORIZED', // 'BAD_REQUEST', 'NOT_FOUND', etc.
  message: 'Clear error message'
});
```

### Service Pattern
```typescript
// modules/queue/services/queue.service.ts
export class QueueService {
  constructor(
    private authService: AuthService,    // ‚úÖ Dependency injection
    private userService: UserService    // ‚úÖ From allowed dependencies
  ) {}

  async getQueue(filters: QueueFilters): Promise<QueueResult> {
    // Business logic here
  }
}
```

## üîê Authentication & Security

### JWT + Next.js Middleware
```typescript
interface JwtPayload {
  id: number;
  email: string;
  role: 'agent' | 'supervisor' | 'admin';
  iat: number;
  exp: number;
}

// middleware.ts protects /dashboard routes
// Uses JWT tokens with 8-hour expiration
```

### Magic Link Generation
```typescript
// Maintain compatibility with main system
const generateMagicLink = (userId: number, type: MagicLinkType): string => {
  const mlid = Buffer.from(userId.toString()).toString('base64');
  return `${process.env.MAIN_APP_URL}/claims?mlid=${mlid}`;
};
```

## üìã Current Queue System

### Three Specialized Queues
1. **üñäÔ∏è Unsigned Users** (Highest Priority) - Missing signatures
2. **üìã Outstanding Requests** (Medium Priority) - Pending documents  
3. **üìû Callbacks** (User-Scheduled Priority) - Requested callbacks

### Enhanced Features (Production)
- **Auto-regeneration**: Maintains 20+ users automatically
- **Enhanced ordering**: Newest-first for same scores
- **2-hour cooling**: Prevents rushed calls on fresh leads
- **Separated tables**: Optimized performance
- **Real-time monitoring**: 5-minute health checks

## ü§ñ AI & Automation Features

### Hume EVI Integration
```typescript
// AI voice conversations with emotional intelligence
const aiService = new AIVoiceService(defaultHumeConfig);
const conversation = await aiService.startConversation({
  callSid, fromNumber, toNumber, userId
});
```

### Background Automation (Production Cron Jobs)
- **queue-level-check**: Auto-regeneration (every 5 minutes)
- **populate-separated-queues**: Full refresh (hourly)
- **discover-new-requirements**: New user discovery (hourly)
- **daily-cleanup**: Database maintenance (daily 2 AM)
- **callback-notifications**: Process callbacks (every minute)
- **scoring-maintenance**: Ensure proper scoring (hourly)

## üö¢ Deployment Workflow

### ‚ö†Ô∏è CRITICAL: Updated Deployment Process

#### Development
```bash
# Push changes to DEV environment
vercel --dev    # Deploy to development
# Test in dev environment before production
```

#### Production  
```bash
# Production deployments ONLY via merge request
git checkout main
git merge feature-branch
git push origin main
# Vercel auto-deploys main branch to production
```

**üö® NEVER deploy directly to production via CLI**
**‚úÖ ALWAYS use merge requests for production changes**

### Environment Configuration
- **Development**: Via Vercel CLI to dev instance
- **Production**: Auto-deployment from main branch
- **Background Jobs**: Configured via vercel.json cron schedules

## üìä Performance Targets

### Production Metrics
- **Queue Load Time**: < 1 second (separated tables)
- **Pre-call Validation**: < 500ms (real-time)
- **Call Accuracy**: 100% (zero wrong calls)
- **Auto-Regeneration**: < 10 seconds for full refresh

## üéØ Business Rules (Enforce in Code)

### Call Restrictions
- No calls before 9 AM or after 8 PM local time
- Maximum 3 attempts per user per week  
- 48-hour cooldown after "not interested"
- Callbacks take priority over new queue entries

### Data Integrity
- **Never modify replica data** (read-only MySQL)
- **Always validate** phone numbers before calling
- **Maintain audit trail** of all actions
- **Pre-call validation** ensures 100% accuracy

## üîÑ File Naming Conventions

```
üìÅ Modules: camelCase (auth/, queue/, calls/)
üìÑ Services: camelCase (auth.service.ts, queue.service.ts)
üìÑ Components: PascalCase (LoginForm.tsx, QueueDashboard.tsx)
üìÑ Hooks: camelCase (useAuth.ts, useQueue.ts)
üìÑ Types: camelCase (auth.types.ts, queue.types.ts)
üìÑ Utils: camelCase (jwt.utils.ts, scoring.utils.ts)

üè† App Router: page.tsx, layout.tsx, route.ts
üîó tRPC: camelCase (auth.ts, queue.ts)
üóÑÔ∏è Database: snake_case (call_sessions, user_scores)
```

## üéÆ Development Guidelines

### Module-First Development
1. **Define module interface** in index.ts first
2. **Implement service** with dependency injection
3. **Create tRPC router** that delegates to service
4. **Add UI components** to module
5. **Export everything** needed via module index

### Type-First Development  
```typescript
// Always define complete types before implementation
interface UserCallContext {
  user: { id: number; firstName: string; /* ... */ };
  claims: Array<{ id: number; type: string; /* ... */ }>;
  callScore: { currentScore: number; /* ... */ };
}
```

### Import Conventions
```typescript
// ‚úÖ Module imports via index
import { QueueService, useQueue } from '@/modules/queue'

// ‚úÖ Internal module imports  
import { validateUser } from './utils/validation.utils'

// ‚úÖ Core shared utilities
import { logger } from '@/modules/core'

// ‚ùå Never cross-module internals
import { QueueService } from '@/modules/queue/services/queue.service'
```

## üìã Critical Success Factors

### For AI Development
- **Respect module boundaries** - never import across internal boundaries
- **Use dependency injection** - services receive dependencies
- **Delegate tRPC to services** - routers are thin layers
- **Follow naming conventions** - consistent file/function naming
- **Maintain type safety** - end-to-end TypeScript
- **Test module isolation** - ensure clean boundaries

### Production Deployment
- **Use merge requests only** for production changes
- **Test in dev first** using Vercel CLI 
- **Monitor health endpoints** after deployment
- **Respect business rules** in all new features
- **Maintain backward compatibility** with main app

---

**Remember**: This is a **production system** serving real users. Always prioritize stability, maintain module boundaries, and use the established deployment workflow.
---

**Remember**: This is a **production system** serving real users. Always prioritize stability, maintain module boundaries, and use the established deployment workflow.
---

**Remember**: This is a **production system** serving real users. Always prioritize stability, maintain module boundaries, and use the established deployment workflow.